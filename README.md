# 8-2-Journal-Portfolio-Submission
CS 230 Module Eight Journal Reflection

For this course, my client was The Gaming Room, and the software I designed was for their game Draw It or Lose It. The company wanted to expand from an Android-only version into a distributed, web-based application that could support thousands of concurrent players across desktop and mobile platforms. My design focused on a server-hosted back end, a responsive browser-based front end, and a scalable architecture that could support growth while keeping the game reliable and secure. 

CS230 ProjectThree Software Des…

What I think I did particularly well in this documentation was connecting the client’s business goals to technical decisions. I did not just list options—I compared platforms and explained why a Linux-based server environment made the most sense for cost, scalability, and deployment flexibility. I also think I did a good job explaining architecture topics like storage, memory management, distributed systems, and security in a way that supports both the client and the development team. Working through the design document was helpful because it forced me to think through requirements and constraints before writing code, which makes development more organized and reduces guesswork later. 

CS230 ProjectThree Software Des…

If I could revise one part of my work, I would probably strengthen the design even more by adding diagrams and more detailed implementation examples (such as API flow examples or deployment diagrams) to make the transition from design to development even clearer. I interpreted the user’s needs by focusing on cross-platform access, scalability, consistency of shared game state, and security of user/game data. That is important because if you miss the user’s actual needs, the software can be technically functional but still fail to solve the real problem. My approach to software design was to start with the requirements, identify constraints, compare platform options, and then make recommendations based on performance, maintainability, scalability, and security. In the future, I would use this same approach again, but I would also add more early validation of assumptions and visual architecture documentation to improve communication even more. 
